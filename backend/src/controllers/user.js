import {
  changePasswordSchema,
  resetPasswordSchema,
  signinSchema,
  signupSchema,
  updateAdminSchema,
  updateSchema,
} from "../Schema/user.js";

import { ObjectId } from "mongodb";
import Product from "../models/product.js";
import Role from "../models/role.js";
import User from "../models/user.js";
import bcrypt from "bcryptjs";
import dotenv from "dotenv";
import jwt from "jsonwebtoken";
import nodemailer from "nodemailer";

dotenv.config();
let isLoggedOut = false;
const { SECRET_CODE, EMAIL_USERNAME, EMAIL_PASSWORD } = process.env;

const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: EMAIL_USERNAME,
    pass: EMAIL_PASSWORD,
  },
});

export const signout = async (req, res) => {
  try {
    if (isLoggedOut) {
      return res.status(400).json({
        message: "B·∫°n ƒë√£ ƒëƒÉng xu·∫•t r·ªìi",
      });
    }
    // X√≥a token b·∫±ng c√°ch x√≥a cookie ch·ª©a token
    res.clearCookie("token");

    // ƒê√°nh d·∫•u ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng xu·∫•t
    isLoggedOut = true;

    return res.status(200).json({
      message: "ƒêƒÉng xu·∫•t th√†nh c√¥ng",
    });
    //res.redirect("/");  Chuy·ªÉn h∆∞·ªõng ng∆∞·ªùi d√πng v·ªÅ trang ch·ªß
  } catch (error) {
    return res.status(500).json({
      message: "L·ªói server",
    });
  }
};

export const signupUser = async (req, res) => {
  const { name, fullname, ngaysinh, trang_thai, email, password, image_url } =
    req.body;

  try {
    // validate ƒë·∫ßu v√†o
    const { error } = signupSchema.validate(req.body, { abortEarly: false });
    if (error) {
      const errors = error.details.map((err) => err.message);
      return res.status(400).json({
        messages: errors,
      });
    }

    // Ki·ªÉm tra trong db c√≥ tk kh√¥ng?
    const userExist = await User.findOne({ email: req.body.email });
    if (userExist) {
      return res.status(400).json({
        messages: "Email ƒë√£ t·ªìn t·∫°i",
      });
    }

    // T√¨m vai tr√≤ "user" trong c∆° s·ªü d·ªØ li·ªáu
    let userRole = await Role.findOne({ role_name: "user" });
    if (!userRole) {
      // N·∫øu vai tr√≤ "user" ch∆∞a t·ªìn t·∫°i, t·∫°o m·ªõi n√≥
      userRole = await Role.create({
        role_name: "user",
        description: "ng∆∞·ªùi d√πng",
      });
    }

    // T·∫°o ng∆∞·ªùi d√πng v·ªõi vai tr√≤ "user" v√† c√°c th√¥ng tin kh√°c
    const user = await User.create({
      name,
      fullname,
      ngaysinh,
      email,
      image_url,
      password,
      role: userRole._id, // G√°n vai tr√≤ "user"
    });

    // M√£ h√≥a m·∫≠t kh·∫©u
    const hashedPassword = await bcrypt.hash(password, 10);
    user.password = hashedPassword;
    await user.save();

    // G·ª≠i email th√¥ng b√°o t·∫°o t√†i kho·∫£n th√†nh c√¥ng
    const mailOptions = {
      from: "your-email@example.com", // ƒê·ªãa ch·ªâ email g·ª≠i
      to: email, // ƒê·ªãa ch·ªâ email ng∆∞·ªùi nh·∫≠n
      subject: "Ch√†o M·ª´ng", // Ti√™u ƒë·ªÅ email
      text: "Ch√∫c m·ª´ng b·∫°n ƒë√£ ƒëƒÉng k√Ω th√†nh c√¥ng t√†i kho·∫£n", // N·ªôi dung email
    };

    transporter.sendMail(mailOptions, (error, info) => {
      if (error) {
        console.log("Error sending email:", error);
      } else {
        console.log("Email sent:", info.response);
      }
    });

    return res.status(201).json({
      message: "T·∫°o t√†i kho·∫£n th√†nh c√¥ng",
      user,
    });
  } catch (error) {
    res.status(500).json({
      message: error.message,
    });
  }
};

export const signup = async (req, res) => {
  const {
    name,
    fullname,
    ngaysinh,
    trang_thai,
    email,
    password,
    role: role_name,
    image_url,
  } = req.body;

  try {
    // validate ƒë·∫ßu v√†o
    const { error } = signupSchema.validate(req.body, { abortEarly: false });
    if (error) {
      const errors = error.details.map((err) => err.message);
      return res.status(400).json({
        messages: errors,
      });
    }

    // Ki·ªÉm tra trong db c√≥ tk kh√¥ng?
    const userExist = await User.findOne({ email: req.body.email });
    if (userExist) {
      return res.status(400).json({
        messages: "Email ƒë√£ t·ªìn t·∫°i",
      });
    }

    console.log("üöÄ ~ signup ~ role_name:", role_name);
    // T√¨m vai tr√≤ trong db d·ª±a tr√™n role_name

    // const role = await Role.findOne({ _id: role_name });

    // if (!role) {
    //   return res.status(400).json({
    //     messages: "Kh√¥ng t√¨m th·∫•y vai tr√≤",
    //   });
    // }

    // M√£ h√≥a m·∫≠t kh·∫©u
    const hashedPassword = await bcrypt.hash(req.body.password, 10);

    // T·∫°o ng∆∞·ªùi d√πng v·ªõi vai tr√≤ v√† c√°c th√¥ng tin kh√°c
    const user = await User.create({
      name,
      fullname,
      ngaysinh,
      email,
      image_url,
      password: hashedPassword,
      role: "6545036de84d7e9cc42a5050",
    });
    user.password = undefined;
    // G·ª≠i email th√¥ng b√°o t·∫°o t√†i kho·∫£n th√†nh c√¥ng
    const mailOptions = {
      from: "your-email@example.com", // ƒê·ªãa ch·ªâ email g·ª≠i
      to: email, // ƒê·ªãa ch·ªâ email ng∆∞·ªùi nh·∫≠n
      subject: "Ch√†o M·ª´ng", // Ti√™u ƒë·ªÅ email
      text: "Ch√∫c m·ª´ng b·∫°n ƒë√£ ƒëƒÉng k√Ω th√†nh c√¥ng t√†i kho·∫£n", // N·ªôi dung email
    };

    transporter.sendMail(mailOptions, (error, info) => {
      if (error) {
        console.log("Error sending email:", error);
      } else {
        console.log("Email sent:", info.response);
      }
    });

    return res.status(201).json({
      message: "T·∫°o t√†i kho·∫£n th√†nh c√¥ng",
      user,
    });
  } catch (error) {
    res.status(500).json({
      message: error.message,
    });
  }
};

export const signin = async (req, res) => {
  try {
    const { email, password } = req.body;
    const { error } = signinSchema.validate(req.body, {
      abortEarly: false,
    });
    if (error) {
      return res.json({
        success: false,
        messages: error.details.map((detail) => detail.message),
      });
    }
    const haveUser = await User.findOne({ email }).populate(
      "role",
      "id role_name"
    );
    if (!haveUser) {
      return res.status(400).json({
        message: "Email kh√¥ng t·ªìn t·∫°i",
      });
    }
    // if (haveUser.isBlocked) {
    //   return res.status(403).json({ message: "T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã kh√≥a" });
    // }
    const checkPass = await bcrypt.compare(password, haveUser.password);
    if (!checkPass) {
      return res.status(400).json({
        message: "M·∫≠t kh·∫©u kh√¥ng ch√≠nh x√°c",
      });
    }
    const token = jwt.sign(
      {
        id: haveUser._id,
      },
      SECRET_CODE,
      { expiresIn: "1d" }
    );

    // ƒê·∫∑t JWT v√†o cookie thay v√¨ accessToken
    res.cookie("jwt", token, { httpOnly: true, maxAge: 86400000 }); // 1 ng√†y

    haveUser.password = undefined;
    return res.status(200).json({
      message: "ƒêƒÉng nh·∫≠p th√†nh c√¥ng",
      user: haveUser,
    });
  } catch (error) {
    return res.status(500).json({
      message: "L·ªói server",
    });
  }
};

export const signIn = async (req, res) => {
  try {
    const { error } = signinSchema.validate(req.body, { abortEarly: false });
    if (error) {
      const errors = error.details.map((err) => err.message);

      return res.status(400).json({
        messages: errors,
      });
    }

    const user = await User.findOne({ email: req.body.email }).populate(
      "role",
      "id role_name"
    );
    if (!user) {
      return res.status(400).json({
        messages: "Email kh√¥ng t·ªìn t·∫°i",
      });
    }

    const isMatch = await bcrypt.compare(req.body.password, user.password);
    if (!isMatch) {
      return res.status(400).json({
        messages: "Sai m·∫≠t kh·∫©u",
      });
    }
    const token = jwt.sign({ id: user._id }, SECRET_CODE, { expiresIn: "1d" });
    user.password = undefined;

    return res.status(200).json({
      message: "ƒêƒÉng nh·∫≠p th√†nh c√¥ng",
      accessToken: token,
      user,
    });
  } catch (error) {
    res.status(500).json({
      message: "Loi server!",
    });
  }
};

export const getAll = async (req, res) => {
  try {
    const users = await User.find().populate("role", "role_name");

    if (users.length === 0) {
      return res.json({
        message: "Kh√¥ng c√≥ user n√†o!",
      });
    }

    return res.json({
      message: "L·∫•y danh s√°ch user th√†nh c√¥ng!",
      users,
    });
  } catch (error) {
    return res.status(400).json({
      message: error.message,
    });
  }
};

export const remove = async (req, res) => {
  try {
    const user = await User.findByIdAndDelete(req.params.id);
    if (!user) {
      return res.json({
        message: "XoÃÅa user kh√¥ng thaÃÄnh c√¥ng",
      });
    }
    return res.json({
      message: "XoÃÅa user thaÃÄnh c√¥ng",
      user,
    });
  } catch (error) {
    if (error.name === "CastError") {
      return res.status(400).json({ message: "Id kh√¥ng h·ª£p l·ªá" });
    }
  }
};

export const update = async (req, res) => {
  try {
    // L·∫•y th√¥ng tin user t·ª´ c∆° s·ªü d·ªØ li·ªáu
    const user = await User.findById(req.params.id);
    if (!user) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y user" });
    }

    // So s√°nh m·∫≠t kh·∫©u c≈© ƒë√£ hash v·ªõi m·∫≠t kh·∫©u m·ªõi ƒë∆∞·ª£c g·ª≠i t·ª´ client

    // Validate th√¥ng tin c·∫ßn update
    const { error } = updateSchema.validate(req.body, { abortEarly: false });
    if (error) {
      return res.status(400).json({
        message: error.details.map((error) => error.message),
      });
    }
    // const passwordsMatch = await bcrypt.compare(
    //   req.body.confirmPassword,
    //   user.password
    // );
    // if (!passwordsMatch) {
    //   return res.status(400).json({ message: "M·∫≠t kh·∫©u kh√¥ng kh·ªõp" });
    // }

    // Th·ª±c hi·ªán update th√¥ng tin user
    const updatedUser = await User.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
    });

    return res.json({
      message: "C·∫≠p nh·∫≠t th√¥ng tin user th√†nh c√¥ng!",
      user: updatedUser,
    });
  } catch (error) {
    if (error.name === "CastError") {
      return res.status(400).json({ message: "Id kh√¥ng h·ª£p l·ªá" });
    }
    return res.status(500).json({ message: "L·ªói server" });
  }
};

export const updateAdmin = async (req, res) => {
  try {
    // L·∫•y th√¥ng tin user t·ª´ c∆° s·ªü d·ªØ li·ªáu
    const user = await User.findById(req.params.id);
    if (!user) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y user" });
    }
    const { error } = updateAdminSchema.validate(req.body, {
      abortEarly: false,
    });
    if (error) {
      return res.status(400).json({
        message: error.details.map((error) => error.message),
      });
    }

    // L·∫•y th√¥ng tin role t·ª´ c∆° s·ªü d·ªØ li·ªáu n·∫øu c√≥ thay ƒë·ªïi
    let role = user.role;
    if (req.body.role_name && req.body.role_name !== user.role.role_name) {
      role = await Role.findOne({ role_name: req.body.role_name });
      if (!role) {
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y role" });
      }
    }

    // Th·ª±c hi·ªán update th√¥ng tin user
    const updatedUser = await User.findByIdAndUpdate(
      req.params.id,
      { role: role._id },
      {
        new: true,
      }
    ).populate("role", "role_name");

    return res.json({
      message: "C·∫≠p nh·∫≠t th√¥ng tin user th√†nh c√¥ng!",
      user: updatedUser,
    });
  } catch (error) {
    if (error.name === "CastError") {
      return res.status(400).json({ message: "Id kh√¥ng h·ª£p l·ªá" });
    }
    return res.status(500).json({ message: "L·ªói server" });
  }
};
export const get = async (req, res) => {
  try {
    const user = await User.findById(req.params.id).populate(
      "role",
      "id role_name"
    );
    const favoriteProduct = await Product.find({
      _id: { $in: user.favoriteProducts },
    });
    if (!user) {
      return res.json({
        message: "L·∫•y user kh√¥ng th√†nh c√¥ng!",
      });
    }
    return res.json({
      message: "L·∫•y th√¥ng tin user th√†nh c√¥ng!",
      user,
      favoriteProduct,
    });
  } catch (error) {
    if (error.name === "CastError") {
      return res.status(400).json({ message: "Id kh√¥ng h·ª£p l·ªá" });
    }
  }
};

export const changePassword = async (req, res) => {
  try {
    const userId = req.params.userId;
    const { oldPassword, newPassword, confirmPassword } = req.body;

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i" });
    }

    const { error } = changePasswordSchema.validate(
      { oldPassword, newPassword, confirmPassword },
      { abortEarly: false }
    );
    if (error) {
      return res.status(400).json({
        message: "L·ªói x√°c nh·∫≠n m·∫≠t kh·∫©u m·ªõi",
        details: error.details.map((detail) => detail.message),
      });
    }

    const isOldPasswordValid = await bcrypt.compare(oldPassword, user.password);
    if (!isOldPasswordValid) {
      return res.status(401).json({ message: "M·∫≠t kh·∫©u c≈© kh√¥ng ƒë√∫ng" });
    }

    if (newPassword !== confirmPassword) {
      return res
        .status(400)
        .json({ message: "M·∫≠t kh·∫©u m·ªõi v√† x√°c nh·∫≠n m·∫≠t kh·∫©u kh√¥ng kh·ªõp" });
    }

    const hashedPassword = await bcrypt.hash(newPassword, 10);
    user.password = hashedPassword;
    await user.save();

    return res.json({ message: "ƒê·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng" });
  } catch (error) {
    console.error("L·ªói:", error);
    res.status(500).json({ message: "L·ªói server" });
  }
};

export const forgotPassword = async (req, res) => {
  try {
    const { email } = req.body;
    // Ki·ªÉm tra xem email c√≥ t·ªìn t·∫°i trong c∆° s·ªü d·ªØ li·ªáu
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({
        message: "Email kh√¥ng t·ªìn t·∫°i",
      });
    }
    // T·∫°o m√£ OTP ng·∫´u nhi√™n
    const otp = Math.floor(100000 + Math.random() * 900000);
    // G·ª≠i m√£ OTP qua email
    const transporter = nodemailer.createTransport({
      service: "gmail",
      auth: {
        user: EMAIL_USERNAME,
        pass: EMAIL_PASSWORD,
      },
    });
    // H√†m ƒë·ªÉ g·ª≠i email
    async function sendEmail(email, otp) {
      try {
        const info = await transporter.sendMail({
          from: "vietquang1312002@gmail.com", // ƒêi·ªÅn th√¥ng tin ng∆∞·ªùi g·ª≠i ·ªü ƒë√¢y
          to: email, // ƒê·ªãa ch·ªâ email ng∆∞·ªùi nh·∫≠n
          subject: "M√£ x√°c nh·∫≠n ƒë·ªïi m·∫≠t kh·∫©u", // Ti√™u ƒë·ªÅ email
          text: `M√£ x√°c nh·∫≠n c·ªßa b·∫°n l√†: ${otp}`, // N·ªôi dung email d·∫°ng text
        });
        console.log("Message sent: %s", info.messageId);
        return true;
      } catch (error) {
        console.error(error);
        return false;
      }
    }
    // S·ª≠ d·ª•ng h√†m sendEmail ƒë·ªÉ g·ª≠i email
    async function main() {
      const { email } = req.body;
      const user = await User.findOne({ email });
      if (!user) {
        return res.status(400).json({
          message: "Email kh√¥ng t·ªìn t·∫°i",
        });
      }
      // T·∫°o m√£ OTP ng·∫´u nhi√™n
      const otp = Math.floor(1000 + Math.random() * 9000);
      // G·ª≠i email
      const emailSent = await sendEmail(email, otp);
      if (emailSent) {
        // L∆∞u m√£ OTP v√†o c∆° s·ªü d·ªØ li·ªáu
        user.otp = otp;
        user.save();
        return res
          .status(200)
          .json({ message: "M√£ x√°c nh·∫≠n ƒë√£ ƒë∆∞·ª£c g·ª≠i qua email." });
      } else {
        return res.status(500).json({ message: "L·ªói khi g·ª≠i email x√°c nh·∫≠n." });
      }
    }
    main().catch(console.error);
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      message: "L·ªói server",
    });
  }
};



export const otpauthentication = async (req, res) => {
  try {
    const { email, otp } = req.body;

    // Ki·ªÉm tra xem m√£ OTP ng∆∞·ªùi d√πng nh·∫≠p c√≥ kh·ªõp v·ªõi m√£ OTP m·ªõi trong c∆° s·ªü d·ªØ li·ªáu kh√¥ng
    const user = await User.findOne({ email, otp });

    if (!user) {
      return res.status(400).json({ message: "M√£ x√°c nh·∫≠n kh√¥ng h·ª£p l·ªá." });
    }

    // G·ª≠i th√¥ng b√°o x√°c nh·∫≠n m√£ OTP th√†nh c√¥ng
    return res.status(200).json({ message: "M√£ OTP x√°c nh·∫≠n th√†nh c√¥ng." });
  } catch (error) {
    return res.status(500).json({
      message: "L·ªói server",
    });
  }
};

export const resetPassword = async (req, res) => {
  try {
    const { email, newPassword, confirmPassword } = req.body;

    // Ki·ªÉm tra xem d·ªØ li·ªáu ƒë·∫ßu v√†o ph√π h·ª£p v·ªõi schema
    const validation = resetPasswordSchema.validate(
      { newPassword, confirmPassword },
      { abortEarly: false }
    );
    if (validation.error) {
      const errors = validation.error.details.map((error) => error.message);
      return res.status(400).json({ message: errors });
    }

    // T·∫°i ƒë√¢y, x√°c minh m√£ OTP v√† m·∫≠t kh·∫©u ƒë√£ th√†nh c√¥ng, ti·∫øn h√†nh c·∫≠p nh·∫≠t m·∫≠t kh·∫©u
    const hashedPassword = await bcrypt.hash(newPassword, 15);

    // C·∫≠p nh·∫≠t m·∫≠t kh·∫©u v√† x√≥a m√£ OTP
    const user = await User.findOne({ email });
    if (user) {
      user.password = hashedPassword;
      user.otp = null;
      await user.save();
    }

    return res
      .status(200)
      .json({ message: "M·∫≠t kh·∫©u ƒë√£ ƒë∆∞·ª£c ƒë·ªïi th√†nh c√¥ng." });
  } catch (error) {
    return res.status(500).json({
      message: "L·ªói server",
    });
  }
};

export const resendOTP = async (req, res) => {
  try {
    const { email } = req.body;

    const user = await User.findOne({ email });

    if (!user) {
      return res.status(400).json({ message: "Email kh√¥ng t·ªìn t·∫°i" });
    }

    // T·∫°o m√£ OTP ng·∫´u nhi√™n
    const otp = Math.floor(1000 + Math.random() * 9000);

    // G·ª≠i l·∫°i m√£ OTP qua email
    const emailSent = await sendEmail(email, otp);

    if (emailSent) {
      // C·∫≠p nh·∫≠t m√£ OTP m·ªõi v√†o c∆° s·ªü d·ªØ li·ªáu
      user.otp = otp;
      await user.save();

      return res
        .status(200)
        .json({ message: "M√£ x√°c nh·∫≠n m·ªõi ƒë√£ ƒë∆∞·ª£c g·ª≠i qua email." });
    } else {
      return res
        .status(500)
        .json({ message: "L·ªói khi g·ª≠i l·∫°i email x√°c nh·∫≠n." });
    }
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      message: "L·ªói server",
    });
  }
};

async function sendEmail(email, otp) {
  try {
    const transporter = nodemailer.createTransport({
      host: "smtp.gmail.com",
      port: 465,
      secure: true,
      auth: {
        user: EMAIL_USERNAME,
        pass: EMAIL_PASSWORD,
      },
    });

    const info = await transporter.sendMail({
      from: "your-email@gmail.com",
      to: email,
      subject: "M√£ x√°c nh·∫≠n ƒë·ªïi m·∫≠t kh·∫©u",
      text: `M√£ x√°c nh·∫≠n c·ªßa b·∫°n l√†: ${otp}`,
    });

    console.log("Message sent: %s", info.messageId);
    return true;
  } catch (error) {
    console.error(error);
    return false;
  }
}
